---
/**
 * SplitLayout.astro
 * 
 * Main container for the split-screen educational experience.
 * Left: Chat-style content panel with sequential message reveal
 * Right: Animation panel with terminal-style visuals (dimmed until content completes)
 */

import type { SectionData } from '../lib/sections';
import WelcomeScreen from './WelcomeScreen.astro';
import ChatContentPanel from './ChatContentPanel.astro';
import IntroAnimation from './animations/01-IntroAnimation.astro';
import WhyTerminalAnimation from './animations/02-WhyTerminalAnimation.astro';
import InterfacesAnimation from './animations/03-InterfacesAnimation.astro';
import RawTerminalAnimation from './animations/04-RawTerminalAnimation.astro';
import TranslatorAnimation from './animations/05-TranslatorAnimation.astro';
import PackageManagerAnimation from './animations/06-PackageManagerAnimation.astro';
import CreationAnimation from './animations/07-CreationAnimation.astro';
import MarkdownAnimation from './animations/08-MarkdownAnimation.astro';
import StructureAnimation from './animations/09-StructureAnimation.astro';
import ContextAnimation from './animations/10-ContextAnimation.astro';
import DecoratorsAnimation from './animations/11-DecoratorsAnimation.astro';
import FactoryAnimation from './animations/12-FactoryAnimation.astro';

interface Props {
  sections: SectionData[];
  initialSection?: number;
}

const { sections, initialSection = 1 } = Astro.props;

// Get initial section data
const currentSection = sections[initialSection - 1] || sections[0];
---

<!-- Welcome Screen (shown when no hash) -->
<WelcomeScreen />

<div 
  class="split-layout" 
  data-split-layout
  data-current-section={initialSection}
  data-total-sections={sections.length}
>
  <!-- Section Navigation Header -->
  <header class="split-header">
    <nav class="section-nav" aria-label="Section navigation">
      <button 
        class:list={['nav-btn', 'prev', { hidden: initialSection === 1 }]}
        aria-label="Go to previous section"
        data-prev-btn
      >
        <span class="nav-arrow">&larr;</span>
        <span class="nav-text" data-prev-title>{initialSection > 1 ? sections[initialSection - 2].title : ''}</span>
      </button>
      
      <button 
        class:list={['nav-btn', 'next', { hidden: initialSection === sections.length }]}
        aria-label="Go to next section"
        data-next-btn
      >
        <span class="nav-text" data-next-title>{initialSection < sections.length ? sections[initialSection].title : ''}</span>
        <span class="nav-arrow">&rarr;</span>
      </button>
    </nav>
  </header>

  <!-- Main Split Panels -->
  <main class="split-panels">
    <!-- Chat Content Panel (Left) - starts active -->
    <div class="panel-wrapper content-panel-wrapper" data-panel="content">
      {sections.map((section, index) => (
        <div 
          class="chat-panel-container" 
          data-section-panel={section.id}
          style={index === initialSection - 1 ? '' : 'display: none;'}
        >
          <ChatContentPanel
            sectionTitle={section.title}
            sectionNumber={section.number}
            totalSections={sections.length}
            messages={section.messages}
            sectionId={section.id}
            timeline={section.timeline}
          />
        </div>
      ))}
    </div>

    <!-- Animation Panel (Right) - starts dimmed -->
    <div class="panel-wrapper animation-panel-wrapper dimmed" data-panel="animation">
      <div class="animation-panel" aria-label="Visual demonstration">
        <!-- Waiting indicator (shown when dimmed) -->
        <div class="animation-waiting" data-animation-waiting>
          <div class="waiting-content">
            <div class="waiting-icon">
              <span class="waiting-dot"></span>
              <span class="waiting-dot"></span>
              <span class="waiting-dot"></span>
            </div>
            <p class="waiting-text">Read through the content on the left...</p>
          </div>
        </div>
        
        <!-- Section 1: Intro Animation -->
        <div class="animation-container" data-animation-id="intro" style="display: none;">
          <IntroAnimation />
        </div>
        
        <!-- Section 2: Why Terminal Animation -->
        <div class="animation-container" data-animation-id="why-terminal" style="display: none;">
          <WhyTerminalAnimation />
        </div>
        
        <!-- Section 3: Interfaces Animation -->
        <div class="animation-container" data-animation-id="interfaces" style="display: none;">
          <InterfacesAnimation />
        </div>
        
        <!-- Section 4: Raw Terminal Animation -->
        <div class="animation-container" data-animation-id="terminal-raw" style="display: none;">
          <RawTerminalAnimation />
        </div>
        
        <!-- Section 5: Translator Animation -->
        <div class="animation-container" data-animation-id="terminal-translator" style="display: none;">
          <TranslatorAnimation />
        </div>
        
        <!-- Section 6: Package Manager Animation -->
        <div class="animation-container" data-animation-id="packages" style="display: none;">
          <PackageManagerAnimation />
        </div>
        
        <!-- Section 7: Creation Animation -->
        <div class="animation-container" data-animation-id="creation" style="display: none;">
          <CreationAnimation />
        </div>
        
        <!-- Section 8: Markdown Animation -->
        <div class="animation-container" data-animation-id="markdown" style="display: none;">
          <MarkdownAnimation />
        </div>
        
        <!-- Section 9: Structure Animation -->
        <div class="animation-container" data-animation-id="structure" style="display: none;">
          <StructureAnimation />
        </div>
        
        <!-- Section 10: Context Animation -->
        <div class="animation-container" data-animation-id="context" style="display: none;">
          <ContextAnimation />
        </div>
        
        <!-- Section 11: Decorators Animation -->
        <div class="animation-container" data-animation-id="decorators" style="display: none;">
          <DecoratorsAnimation />
        </div>
        
        <!-- Section 12: Factory Animation -->
        <div class="animation-container" data-animation-id="factory" style="display: none;">
          <FactoryAnimation />
        </div>
      </div>
    </div>
  </main>

  <!-- Section Footer with Progress -->
  <footer class="split-footer">
    <div class="progress-bar">
      <div 
        class="progress-fill" 
        style={`width: ${(initialSection / sections.length) * 100}%`}
        role="progressbar"
        aria-valuenow={initialSection}
        aria-valuemin={1}
        aria-valuemax={sections.length}
      ></div>
    </div>
    <div class="footer-info">
      <span class="keyboard-hint">Click or press any key to advance</span>
      <span class="section-count">{initialSection} / {sections.length}</span>
    </div>
  </footer>
</div>

<!-- Hidden data for JavaScript -->
<script define:vars={{ sections: sections.map(s => ({ id: s.id, number: s.number, title: s.title, messages: s.messages, hasAnimation: s.hasAnimation, animationComponent: s.animationComponent })) }}>
  window.__SECTIONS__ = sections;
</script>

<style>
  /* Full-screen immersive layout */
  .split-layout {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    background: #0a0a0f;
    opacity: 1;
    transition: opacity 0.3s ease-out;
  }

  /* Hidden state when welcome screen is active */
  .split-layout.hidden {
    opacity: 0;
    pointer-events: none;
  }
  
  /* Minimal header */
  .split-header {
    background: rgba(10, 10, 15, 0.95);
    backdrop-filter: blur(8px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    position: relative;
    z-index: 100;
    flex-shrink: 0;
  }
  
  .section-nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 1.5rem;
    width: 100%;
  }
  
  .nav-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    font-family: 'Lora', Georgia, serif;
    font-size: 0.8rem;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.5);
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .nav-btn:hover:not(:disabled) {
    color: rgba(255, 255, 255, 0.9);
    border-color: rgba(255, 255, 255, 0.25);
    background: rgba(255, 255, 255, 0.05);
  }
  
  .nav-btn:disabled {
    opacity: 0.25;
    cursor: not-allowed;
  }
  
  .nav-btn.hidden {
    visibility: hidden;
    pointer-events: none;
  }
  
  .nav-arrow {
    font-size: 1rem;
  }
  
  .nav-text {
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  /* Main Panels */
  .split-panels {
    display: grid;
    grid-template-columns: 45% 55%;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }
  
  /* Panel wrappers for dimming - subtle effect to guide user attention */
  .panel-wrapper {
    position: relative;
    overflow: hidden;
    transition: opacity 0.5s ease, filter 0.5s ease;
  }
  
  .panel-wrapper.dimmed {
    opacity: 0.7;
    filter: brightness(0.85);
  }
  
  /* Content panel wrapper */
  .content-panel-wrapper {
    background: linear-gradient(180deg, #0f0f14 0%, #0a0a0f 100%);
    border-right: 1px solid rgba(255, 255, 255, 0.06);
  }
  
  .chat-panel-container {
    height: 100%;
  }
  
  /* Animation panel wrapper */
  .animation-panel-wrapper {
    background: linear-gradient(135deg, #0d0d12 0%, #1a1a2e 100%);
  }
  
  .animation-panel {
    height: 100%;
    width: 100%;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
  }
  
  /* Subtle glow effect on animation panel */
  .animation-panel::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(ellipse at 50% 50%, rgba(59, 130, 246, 0.03) 0%, transparent 70%);
    pointer-events: none;
  }
  
  /* Waiting indicator */
  .animation-waiting {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    opacity: 1;
    transition: opacity 0.4s ease;
  }
  
  .animation-waiting.hidden {
    opacity: 0;
    pointer-events: none;
  }
  
  .waiting-content {
    text-align: center;
  }
  
  .waiting-icon {
    display: flex;
    justify-content: center;
    gap: 6px;
    margin-bottom: 1rem;
  }
  
  .waiting-dot {
    width: 8px;
    height: 8px;
    background: rgba(139, 92, 246, 0.6);
    border-radius: 50%;
    animation: waiting-pulse 1.4s ease-in-out infinite;
  }
  
  .waiting-dot:nth-child(2) {
    animation-delay: 0.2s;
  }
  
  .waiting-dot:nth-child(3) {
    animation-delay: 0.4s;
  }
  
  @keyframes waiting-pulse {
    0%, 80%, 100% {
      opacity: 0.3;
      transform: scale(0.8);
    }
    40% {
      opacity: 1;
      transform: scale(1);
    }
  }
  
  .waiting-text {
    font-family: 'Lora', Georgia, serif;
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.4);
    font-style: italic;
  }
  
  /* Animation containers */
  .animation-container {
    height: 100%;
    width: 100%;
    position: relative;
  }
  
  .animation-container[style*="display: none"] {
    display: none !important;
  }
  
  /* Footer */
  .split-footer {
    background: rgba(10, 10, 15, 0.95);
    backdrop-filter: blur(8px);
    border-top: 1px solid rgba(255, 255, 255, 0.06);
    flex-shrink: 0;
  }
  
  .progress-bar {
    height: 2px;
    background: rgba(255, 255, 255, 0.05);
    overflow: hidden;
  }
  
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #8b5cf6);
    transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .footer-info {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.4rem 1.5rem;
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.35);
  }
  
  .keyboard-hint {
    font-family: 'Lora', Georgia, serif;
    opacity: 0.7;
  }
  
  .section-count {
    font-family: 'JetBrains Mono', monospace;
  }
  
  /* Responsive - tablet */
  @media (max-width: 1024px) {
    .split-panels {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
    }
    
    .nav-text {
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 0.75rem;
    }
    
    .nav-btn {
      padding: 0.5rem 0.75rem;
    }
  }
  
  /* Responsive - mobile */
  @media (max-width: 640px) {
    .section-nav {
      padding: 0.4rem 1rem;
    }
    
    .footer-info {
      padding: 0.3rem 1rem;
    }
  }
  
  /* Ultra-wide screens */
  @media (min-width: 2000px) {
    .split-panels {
      grid-template-columns: 40% 60%;
    }
  }
  
  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .panel-wrapper {
      transition: none;
    }
    
    .waiting-dot {
      animation: none;
      opacity: 0.6;
    }
  }
</style>

<script>
  // Types
  interface SectionData {
    id: string;
    number: number;
    title: string;
    messages: string[];
    hasAnimation: boolean;
    animationComponent: string | null;
  }

  // State
  const sections: SectionData[] = (window as any).__SECTIONS__ || [];
  let currentSectionIndex = 0;
  let animationPlaying = false;

  // DOM Elements
  const layout = document.querySelector('[data-split-layout]') as HTMLElement;
  const contentPanelWrapper = document.querySelector('[data-panel="content"]') as HTMLElement;
  const animationPanelWrapper = document.querySelector('[data-panel="animation"]') as HTMLElement;
  const animationWaiting = document.querySelector('[data-animation-waiting]') as HTMLElement;
  const prevBtn = document.querySelector('[data-prev-btn]') as HTMLButtonElement;
  const nextBtn = document.querySelector('[data-next-btn]') as HTMLButtonElement;
  const prevTitleEl = document.querySelector('[data-prev-title]') as HTMLElement;
  const nextTitleEl = document.querySelector('[data-next-title]') as HTMLElement;
  const progressFill = document.querySelector('.progress-fill') as HTMLElement;
  const sectionCountEl = document.querySelector('.section-count') as HTMLElement;
  const animationContainers = document.querySelectorAll('[data-animation-id]') as NodeListOf<HTMLElement>;
  const sectionPanels = document.querySelectorAll('[data-section-panel]') as NodeListOf<HTMLElement>;

  // Map section IDs to animation IDs
  const sectionAnimationMap: Record<string, string> = {
    'intro': 'intro',
    'why-terminal': 'why-terminal',
    'interfaces': 'interfaces',
    'terminal-raw': 'terminal-raw',
    'terminal-translator': 'terminal-translator',
    'packages': 'packages',
    'creation': 'creation',
    'markdown': 'markdown',
    'structure': 'structure',
    'context': 'context',
    'decorators': 'decorators',
    'factory': 'factory',
  };

  // Welcome state management
  function isWelcomeState(): boolean {
    return !window.location.hash;
  }

  function updateLayoutVisibility() {
    if (!layout) return;
    if (isWelcomeState()) {
      layout.classList.add('hidden');
    } else {
      layout.classList.remove('hidden');
    }
  }

  // Panel dimming control - only animation panel dims, content panel never dims
  function setAnimationPanelDimmed(dimmed: boolean) {
    if (dimmed) {
      animationPanelWrapper?.classList.add('dimmed');
      animationWaiting?.classList.remove('hidden');
    } else {
      animationPanelWrapper?.classList.remove('dimmed');
      animationWaiting?.classList.add('hidden');
    }
  }



  // Show animation for section
  function showAnimationForSection(sectionId: string) {
    const animationId = sectionAnimationMap[sectionId];
    
    // Hide all animation containers
    animationContainers.forEach(container => {
      container.style.display = 'none';
    });
    
    if (animationId) {
      const animationContainer = document.querySelector(`[data-animation-id="${animationId}"]`) as HTMLElement;
      if (animationContainer) {
        animationContainer.style.display = 'block';
      }
    }
  }

  // Show section panel
  function showSectionPanel(sectionId: string) {
    sectionPanels.forEach(panel => {
      if (panel.dataset.sectionPanel === sectionId) {
        panel.style.display = '';
      } else {
        panel.style.display = 'none';
      }
    });
  }

  // Update UI
  function updateUI() {
    const section = sections[currentSectionIndex];
    if (!section) return;
    
    const totalSections = sections.length;
    const isFirst = currentSectionIndex === 0;
    const isLast = currentSectionIndex === totalSections - 1;
    
    // Update prev button - hidden on first section, shows previous title
    if (prevBtn) {
      prevBtn.classList.toggle('hidden', isFirst);
      if (!isFirst && prevTitleEl) {
        prevTitleEl.textContent = sections[currentSectionIndex - 1].title;
      }
    }
    
    // Update next button - hidden on last section, shows next title
    if (nextBtn) {
      nextBtn.classList.toggle('hidden', isLast);
      if (!isLast && nextTitleEl) {
        nextTitleEl.textContent = sections[currentSectionIndex + 1].title;
      }
    }
    
    // Update progress
    const progress = ((currentSectionIndex + 1) / totalSections) * 100;
    if (progressFill) progressFill.style.width = `${progress}%`;
    if (sectionCountEl) sectionCountEl.textContent = `${currentSectionIndex + 1} / ${totalSections}`;
    
    // Show correct section panel
    showSectionPanel(section.id);
    
    // Show correct animation (but keep panel dimmed until content completes)
    showAnimationForSection(section.id);
    
    // Reset animation panel to dimmed state (content panel never dims)
    setAnimationPanelDimmed(true);
    animationPlaying = false;
    
    // Update URL hash
    history.replaceState(null, '', `#${section.id}`);
    
    // Dispatch section change event
    document.dispatchEvent(new CustomEvent('section:change', { 
      detail: { section: currentSectionIndex + 1, sectionData: section } 
    }));
  }

  // Navigation
  function goToSection(index: number) {
    if (index < 0 || index >= sections.length) return;
    currentSectionIndex = index;
    if (layout) layout.dataset.currentSection = String(index + 1);
    updateUI();
  }

  function goToPrev() {
    goToSection(currentSectionIndex - 1);
  }

  function goToNext() {
    goToSection(currentSectionIndex + 1);
  }

  // Event Listeners
  
  // Button clicks
  prevBtn?.addEventListener('click', goToPrev);
  nextBtn?.addEventListener('click', goToNext);

  // Advance to next section (from clicking when section is complete)
  document.addEventListener('section:advance-next', (e: Event) => {
    const detail = (e as CustomEvent).detail;
    const section = sections[currentSectionIndex];
    
    if (detail.sectionId === section?.id) {
      goToNext();
    }
  });

  // Replay current section
  document.addEventListener('section:replay', (e: Event) => {
    const detail = (e as CustomEvent).detail;
    const section = sections[currentSectionIndex];
    
    if (detail.sectionId === section?.id) {
      // Reset animation panel to dimmed/waiting state
      setAnimationPanelDimmed(true);
      animationPlaying = false;
      
      // Dispatch event for animation to reset
      document.dispatchEvent(new CustomEvent('animation:reset', {
        detail: { sectionId: section.id }
      }));
    }
  });

  // Chat content completion - trigger animation (legacy mode: sections without timelines)
  document.addEventListener('chat:content-complete', (e: Event) => {
    const detail = (e as CustomEvent).detail;
    const section = sections[currentSectionIndex];
    
    if (detail.sectionId === section?.id && !animationPlaying) {
      animationPlaying = true;
      
      // Undim animation panel
      setAnimationPanelDimmed(false);
      
      // The animation component will pick up the section:change event
      // and start playing (already dispatched, or re-dispatch if needed)
      document.dispatchEvent(new CustomEvent('animation:start', {
        detail: { sectionId: section.id }
      }));
    }
  });

  // Timeline mode: Content pausing for animation beat
  document.addEventListener('content:pausing-for-animation', (e: Event) => {
    const detail = (e as CustomEvent).detail;
    const section = sections[currentSectionIndex];
    
    if (detail.sectionId === section?.id) {
      // Undim animation panel (content panel never dims)
      setAnimationPanelDimmed(false);
    }
  });

  // Timeline mode: Content resuming after animation stage
  document.addEventListener('content:resuming', (e: Event) => {
    const detail = (e as CustomEvent).detail;
    const section = sections[currentSectionIndex];
    
    if (detail.sectionId === section?.id) {
      // Fade animation panel slowly while new content appears on left
      // Uses custom fade duration with easing
      const fadeDuration = detail.fadeDuration || 1400;
      fadeAnimationPanel(fadeDuration);
    }
  });

  /**
   * Fade the animation panel with a smooth easing curve
   * Content appears on left while this fade happens
   */
  function fadeAnimationPanel(durationMs: number) {
    if (!animationPanelWrapper) return;
    
    // Apply custom transition with ease-out curve for smooth fade
    animationPanelWrapper.style.transition = `opacity ${durationMs}ms ease-out, filter ${durationMs}ms ease-out`;
    animationPanelWrapper.classList.add('dimmed');
    
    // Reset transition to default after fade completes
    setTimeout(() => {
      if (animationPanelWrapper) {
        animationPanelWrapper.style.transition = '';
      }
    }, durationMs);
  }

  // Initialize from URL hash
  function initFromHash() {
    const hash = window.location.hash.slice(1);
    if (hash) {
      const sectionIndex = sections.findIndex(s => s.id === hash);
      if (sectionIndex >= 0) {
        currentSectionIndex = sectionIndex;
        updateUI();
      }
    }
  }

  // Layout visibility
  updateLayoutVisibility();
  window.addEventListener('hashchange', () => {
    updateLayoutVisibility();
    initFromHash();
  });

  // Initialize
  initFromHash();
</script>
